package com.redpantssoft.pattern_scanner.regexp

/** Defines a trait for Derivable objects
  *
  * Taken from "Regular Expression Derivatives Reexamined" -Scott Owens, John Reppy,
  * Aaron Turon, In Journal of Functional Programming, March 2009, vol 19, issue 02, pp. 173-190
  *
  * By definition, the derivative of a set of strings S with respect
  * to a symbol a is the set of strings generated by stripping the
  * leading a from the strings in S that start with a.  For regular sets of
  * strings, i.e., sets defined by regular expressions (REs), the derivative
  * is also a regular set. In a 1964 paper, Janusz Brzozowski presented an elegant
  * method for directly constructing a recognizer from a regular expression based
  * on regular-expression derivatives (Brzozowski,1964).
  *
  * The notion of a derivative applies to any language. Intuitively, the derivative of
  * a language L  with respect to a symbol a contained in L  is the language that
  * includes only those suffixes of strings with a leading symbol a in L.
  *
  * This trait extends the concept of what can be derivable from a language by
  * generalizing the operations that allow the construction of matchers and finite
  * state machines from the derivatives.
  *
  * @tparam T type that is derivable
  */
trait Derivable[T] {

  /** A derivative is defined as being nullable if it is equivalent to emptyStr.
    * In terms of a regular expression, this means that the language it defines
    * is an empty string. This is used to indicate that the regular expression
    * derivative currently matches the input
    *
    * @return whether the derivative is nullable
    */
  def nullable: Boolean

  /** A derivative is defined as being final if every possible derivative
    * is equal to the current derivative, meaning that no new derivatives
    * are possible.
    *
    * @return whether the derivative is final
    */
  def isFinal: Boolean


  /** Computes the derivative for this Derivable with respect to c
    *
    * @param c character to calculate a derivative with respect to
    * @return the derivative with respect to the  c
    */
  def derive(c: Char): T

  /** Computes a DerivationMap for this Derivable
    *
    * A DerivationMap defines every possible derivation of this
    * derivable and the character set that the derivation results
    * from
    *
    * @see pattern#DerivationMap  DerivationMap
    * @return DerivationMap for the Derivable
    */
  def derive(): DerivationMap[T]

  /** Computes whether this Derivable  matches a given string
    *
    * This method will compute the derivatives with respect to
    * characters in the string to determine if the Derivable
    * matches it.
    *
    * @param s string to match against
    * @return  indication of whether the string matches
    */
  def matches(s: String): Boolean = Derivable.matches(s, this)
}

object Derivable {

  /** Computes whether a Derivable  matches a given string
    *
    * This method will compute the derivatives with respect to
    * characters in the string to determine if a given Derivable
    * matches it.
    *
    * @param s string to match against
    * @param r Derivable to match against
    * @return  indication of whether the string matches
    */
  def matches[T](s: String, r: Derivable[T]): Boolean = {
    if (s.isEmpty)
      r.nullable
    else
      matches(s.tail, r.derive(s.head).asInstanceOf[Derivable[T]])
  }
}

/** A DerivationMap defines all possible derivations of this Derivable and the
  * character set that produces the derivative.
  *
  * It contains the map, which is a list of derivative, character set pairs, as
  * well as a default derivative, which is valid for every other possible input
  * that is undefined in the map
  *
  * @param list list of derivative to character set pairs
  * @param default  default derivative
  * @tparam T Base type for the Derivable that generated the map
  */
class DerivationMap[T] private(val list: List[(T, Set[Char])], val default: T) {

  /** Returns the derivative with respect to c
    *
    * This will use the already computed derivation map to return the
    * derivative
    *
    * @param c character to calculate a derivative with respect to
    * @return the derivative with respect to the  c
    */
  def derive(c: Char): T = {
    list.find {
      case (dr, chars) => chars.contains(c)
    } match {
      case Some((dr, _)) => dr
      case None => default
    }
  }
}

object DerivationMap {
  def apply[T](list: List[(T, Set[Char])], default: T) =
    new DerivationMap(unique(list), default)

  /** Helper function to guarantee that each derivative in the map is unique */
  private def unique[T](in: List[(T, Set[Char])]): List[(T, Set[Char])] =
    in.groupBy(_._1).values.map {
      (li) => (li.head /: li.tail) {
        (prev, cur) => (prev._1, prev._2.union(cur._2))
      }
    }.toList
}